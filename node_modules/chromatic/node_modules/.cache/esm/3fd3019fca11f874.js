let format,parse,createTask,transitionTo,openTunnel,failed,initial,pending,success;_ca1‍.x([["createTunnel",()=>createTunnel],["testConnection",()=>testConnection],["default",()=>_ca1‍.o]]);_ca1‍.w("url",[["format",["format"],function(v){format=v}],["parse",["parse"],function(v){parse=v}]]);_ca1‍.w("../lib/tasks",[["createTask",["createTask"],function(v){createTask=v}],["transitionTo",["transitionTo"],function(v){transitionTo=v}]]);_ca1‍.w("../lib/tunnel",[["default",["openTunnel"],function(v){openTunnel=v}]]);_ca1‍.w("../ui/tasks/tunnel",[["failed",["failed"],function(v){failed=v}],["initial",["initial"],function(v){initial=v}],["pending",["pending"],function(v){pending=v}],["success",["success"],function(v){success=v}]]);





       const createTunnel = async (ctx) => {
  const { env, log, options } = ctx;
  const { port, pathname, query, hash } = parse(ctx.isolatorUrl, true);

  let tunnel;
  try {
    tunnel = await openTunnel({ env, log, port, https: options.https });
    ctx.closeTunnel = () => tunnel.close();
  } catch (err) {
    if (ctx.stopApp) ctx.stopApp();
    throw err;
  }

  // ** Are we using a v1 or v2 tunnel? **
  // If the tunnel returns a cachedUrl, we are using a v2 tunnel and need to use
  // the slightly esoteric URL format for the isolatorUrl.
  // If not, they are the same:
  const cachedUrlObject = parse(tunnel.cachedUrl || tunnel.url);
  cachedUrlObject.pathname = pathname;
  cachedUrlObject.query = query;
  cachedUrlObject.hash = hash;
  const cachedUrl = cachedUrlObject.format();

  if (tunnel.cachedUrl) {
    const isolatorUrlObject = parse(tunnel.url, true);
    isolatorUrlObject.query = {
      ...isolatorUrlObject.query,
      // This will encode the pathname and query into a single query parameter
      path: format({ pathname, query }),
    };
    isolatorUrlObject.hash = hash;

    // For some reason we need to unset this to change the params
    isolatorUrlObject.search = null;

    // Tunnel v2
    ctx.cachedUrl = cachedUrl;
    ctx.isolatorUrl = isolatorUrlObject.format();
  } else {
    // Tunnel v1
    ctx.isolatorUrl = cachedUrl;
  }
};

       const testConnection = async (ctx) => {
  try {
    await ctx.http.fetch(ctx.isolatorUrl);
  } catch (err) {
    ctx.log.debug(err);
    throw new Error(failed(ctx).output);
  }
};

_ca1‍.d(createTask({
  title: initial.title,
  skip: (ctx) => ctx.skip || !ctx.options.createTunnel,
  steps: [transitionTo(pending), createTunnel, testConnection, transitionTo(success, true)],
}));
